<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aditya</title>
  
  <subtitle>silverf3lix</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://adityapadala.com/"/>
  <updated>2020-04-29T08:13:21.963Z</updated>
  <id>http://adityapadala.com/</id>
  
  <author>
    <name>Aditya Vardhan Padala</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Working with libFuzzer</title>
    <link href="http://adityapadala.com/2020/04/21/Working-with-libFuzzer/"/>
    <id>http://adityapadala.com/2020/04/21/Working-with-libFuzzer/</id>
    <published>2020-04-20T20:11:38.000Z</published>
    <updated>2020-04-29T08:13:21.963Z</updated>
    
    <content type="html"><![CDATA[<p>Libfuzzer is a coverage-guided, evolutionary, inprocess fuzzing engine. Okay lets break it down.</p><ul><li><p><strong>Coverage Guided</strong><br>Fuzz target instrumented to get code coverage reached by each fuzz input. With this info the fuzzer then decides which part of input to mutate to maximize coverage.</p></li><li><p><strong>Evolutionary Fuzzing</strong><br>Using the program’s feedback from the test input to learn the input formate overtime. This works basing onn algorithms similar to genetic algorithms and requires instrumentation.</p></li><li><p><strong>In Process</strong><br>We mutate inputs directly in memory instead of launching a new process for evert input.</p></li></ul><p>Libfuzzer makes it really feasible to fuzz individual components of a program. Meaning that we don’t need to craft a well formed payload and launch huge binaries every run. We can just simply create a fuzzer by just importing<br>all the necessary libraries and calling that one function inside the main fuzzing function.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Say we want to fuzz a function fuzz_me which is a part of a large program and a good fuzz target(more on that later). We just need to write this.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="comment">// We include all necessary headers for the FuzzMe function to work.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FuzzMe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *Data, <span class="keyword">size_t</span> DataSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> DataSize &gt;= <span class="number">3</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">1</span>] == <span class="string">'U'</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">2</span>] == <span class="string">'Z'</span> &amp;&amp;</span><br><span class="line">      Data[<span class="number">3</span>] == <span class="string">'Z'</span>;  <span class="comment">// :‑&lt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Now FuzzMe function is written in such a way that it uses the functions </span></span><br><span class="line"><span class="comment">// that we want to fuzz.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">LLVMFuzzerTestOneInput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *Data, <span class="keyword">size_t</span> Size)</span> </span>&#123;</span><br><span class="line">  FuzzMe(Data, Size);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/google/fuzzing/blob/master/tutorial/libFuzzer/fuzz_me.cc" target="_blank" rel="noopener">source</a></p><p>Now compile it using the required instrumentation with clang.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g -fsanitize=address,fuzzer fuzz_me.cc</span><br></pre></td></tr></table></figure><p>-fsanitize = fuzzer [Links with libFuzzer runtime]<br>-fsanitize = fuzzer, address [enables Address Sanitizer]<br>-fsanitize = fuzzer, signed-integer-overflow [enables UBSAN]<br>-fsanitize = fuzzer, memory [enables MSAN]</p><p>Now lets run the binary.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">silv3r@meltd0wn ~/libFuzzer&gt; ./a.out </span><br><span class="line">INFO: Seed: 3197843689</span><br><span class="line">INFO: Loaded 1 modules   (7 inline 8-bit counters): 7 [0x7a6e80, 0x7a6e87), </span><br><span class="line">INFO: Loaded 1 PC tables (7 PCs): 7 [0x56f7c0,0x56f830), </span><br><span class="line">INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes</span><br><span class="line">INFO: A corpus is not provided, starting from an empty corpus</span><br><span class="line"><span class="meta">#</span><span class="bash">2INITED cov: 3 ft: 4 corp: 1/1b <span class="built_in">exec</span>/s: 0 rss: 27Mb</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5NEW    cov: 4 ft: 5 corp: 2/4b lim: 4 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 3/3 MS: 3 InsertByte-ChangeByte-InsertByte-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1435NEW    cov: 5 ft: 6 corp: 3/19b lim: 17 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 15/15 MS: 5 EraseBytes-EraseBytes-ShuffleBytes-InsertRepeatedBytes-CMP- DE: <span class="string">"F\x00\x00\x00"</span>-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1438REDUCE cov: 5 ft: 6 corp: 3/14b lim: 17 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 10/10 MS: 3 ChangeBit-PersAutoDict-EraseBytes- DE: <span class="string">"F\x00\x00\x00"</span>-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1439REDUCE cov: 5 ft: 6 corp: 3/12b lim: 17 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 8/8 MS: 1 EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1470REDUCE cov: 5 ft: 6 corp: 3/11b lim: 17 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 7/7 MS: 1 EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1526REDUCE cov: 5 ft: 6 corp: 3/10b lim: 17 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 6/6 MS: 1 EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1623REDUCE cov: 5 ft: 6 corp: 3/8b lim: 17 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 4/4 MS: 2 ChangeBinInt-EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1680REDUCE cov: 5 ft: 6 corp: 3/7b lim: 17 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 3/3 MS: 2 ChangeBit-EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6397REDUCE cov: 6 ft: 7 corp: 4/31b lim: 63 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 24/24 MS: 2 InsertRepeatedBytes-ChangeBit-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6404REDUCE cov: 6 ft: 7 corp: 4/22b lim: 63 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 15/15 MS: 2 CMP-EraseBytes- DE: <span class="string">",\x00\x00\x00"</span>-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6477REDUCE cov: 6 ft: 7 corp: 4/15b lim: 63 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 8/8 MS: 3 CopyPart-ChangeBit-EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6483REDUCE cov: 6 ft: 7 corp: 4/14b lim: 63 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 7/7 MS: 1 EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6570REDUCE cov: 6 ft: 7 corp: 4/12b lim: 63 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 5/5 MS: 2 ChangeBit-EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">6658REDUCE cov: 6 ft: 7 corp: 4/10b lim: 63 <span class="built_in">exec</span>/s: 0 rss: 27Mb L: 3/3 MS: 3 ChangeByte-ChangeByte-EraseBytes-</span></span><br><span class="line"><span class="meta">#</span><span class="bash">11580REDUCE cov: 7 ft: 8 corp: 5/14b lim: 110 <span class="built_in">exec</span>/s: 0 rss: 28Mb L: 4/4 MS: 2 InsertByte-ChangeBit-</span></span><br><span class="line">=================================================================</span><br><span class="line">==17776==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000414f3 at pc 0x000000551313 bp 0x7ffec3b75390 sp 0x7ffec3b75388</span><br><span class="line">READ of size 1 at 0x6020000414f3 thread T0</span><br><span class="line">    #0 0x551312 in FuzzMe(unsigned char const*, unsigned long) /home/silv3r/fuzzing/tutorial/libFuzzer/fuzz_me.cc:9:7</span><br><span class="line">    #1 0x5513b4 in LLVMFuzzerTestOneInput /home/silv3r/fuzzing/tutorial/libFuzzer/fuzz_me.cc:13:3</span><br><span class="line">    #2 0x459411 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:553:15</span><br><span class="line">    #3 0x458c55 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:469:3</span><br><span class="line">    #4 0x45aef7 in fuzzer::Fuzzer::MutateAndTestOne() /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:695:19</span><br><span class="line">    #5 0x45bc15 in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:831:5</span><br><span class="line">    #6 0x4499d8 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:825:6</span><br><span class="line">    #7 0x472e42 in main /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10</span><br><span class="line">    #8 0x7fd32099cb96 in __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310</span><br><span class="line">    #9 0x41db69 in _start (/home/silv3r/fuzzing/tutorial/libFuzzer/a.out+0x41db69)</span><br><span class="line"></span><br><span class="line">0x6020000414f3 is located 0 bytes to the right of 3-byte region [0x6020000414f0,0x6020000414f3)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #0 0x51f08d in malloc /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:145:3</span><br><span class="line">    #1 0x432247 in operator new(unsigned long) (/home/silv3r/fuzzing/tutorial/libFuzzer/a.out+0x432247)</span><br><span class="line">    #2 0x458c55 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:469:3</span><br><span class="line">    #3 0x45aef7 in fuzzer::Fuzzer::MutateAndTestOne() /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:695:19</span><br><span class="line">    #4 0x45bc15 in fuzzer::Fuzzer::Loop(std::Fuzzer::vector&lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator&lt;fuzzer::SizedFile&gt; &gt;&amp;) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:831:5</span><br><span class="line">    #5 0x4499d8 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:825:6</span><br><span class="line">    #6 0x472e42 in main /local/mnt/workspace/bcain_clang_bcain-ubuntu_23113/llvm/utils/release/final/llvm.src/projects/compiler-rt/lib/fuzzer/FuzzerMain.cpp:19:10</span><br><span class="line">    #7 0x7fd32099cb96 in __libc_start_main /build/glibc-OTsEL5/glibc-2.27/csu/../csu/libc-start.c:310</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/silv3r/fuzzing/tutorial/libFuzzer/fuzz_me.cc:9:7 in FuzzMe(unsigned char const*, unsigned long)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c0480000240: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480000250: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480000260: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa</span><br><span class="line">  0x0c0480000270: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fd</span><br><span class="line">  0x0c0480000280: fa fa fd fd fa fa fd fd fa fa fd fa fa fa fd fa</span><br><span class="line">=&gt;0x0c0480000290: fa fa fd fa fa fa fd fa fa fa fd fa fa fa[03]fa</span><br><span class="line">  0x0c04800002a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800002b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800002c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800002d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c04800002e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==17776==ABORTING</span><br><span class="line">MS: 1 EraseBytes-; base unit: 095aa46062dcd6efcd6534616616fce2a45abf67</span><br><span class="line">0x46,0x55,0x5a,</span><br><span class="line">FUZ</span><br><span class="line">artifact_prefix='./'; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60</span><br><span class="line">Base64: RlVa</span><br></pre></td></tr></table></figure><p>It should exit quickly throwing out this huge report finding a buffer overflow in FuzzMe function. Easy isn’t it?(Trust me..Not always.)</p><p>Now lets take on an another target which is a bit complex and actually was fuzzed to find a bug.</p><h2 id="Fuzzing-libXML"><a href="#Fuzzing-libXML" class="headerlink" title="Fuzzing libXML"></a>Fuzzing libXML</h2><p><em>To Do</em> All of my work with LibFuzzer will be updated here gradually.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Libfuzzer is a coverage-guided, evolutionary, inprocess fuzzing engine. Okay lets break it down.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Coverage Guided&lt;/s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Setting Up NetBSD Kernel Dev Environment</title>
    <link href="http://adityapadala.com/2020/04/20/Setting-Up-NetBSD-Kernel-Dev-Environment/"/>
    <id>http://adityapadala.com/2020/04/20/Setting-Up-NetBSD-Kernel-Dev-Environment/</id>
    <published>2020-04-20T17:39:42.000Z</published>
    <updated>2020-06-01T07:42:27.200Z</updated>
    
    <content type="html"><![CDATA[<p>This is an overview of my setup:</p><ol><li>Linux Host With Qemu Target</li><li>Tracing and Debugging using qemu’s built-in gdb server.</li><li>pkgin for simpicity.(Sometimes have to use pkg_add to get stuff done)</li></ol><h2 id="Host-Configuration"><a href="#Host-Configuration" class="headerlink" title="Host Configuration"></a>Host Configuration</h2><p>Make sure you have the latest version of qemu installed as we will be using x86-64 NetBSD guests.</p><p>We will be needing GDB that is configured with NetBSD x86_64 abi. So we need to compile it ourself.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/gdb/gdb-xxxx.tar.xz</span><br><span class="line">tar xvf gdb-xxxx.tar.xz</span><br><span class="line">sudo mkdir -p /opt &amp;&amp; cd gdb-xxxx</span><br><span class="line">./configure --prefix=/opt --target=x86_64-netbsd</span><br><span class="line">make -j8 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><h3 id="Building-from-NetBSD-current"><a href="#Building-from-NetBSD-current" class="headerlink" title="Building from NetBSD-current"></a>Building from NetBSD-current</h3><p>First step get the files.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir netbsd &amp;&amp; cd netbsd</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;NetBSD&#x2F;src</span><br><span class="line">cd src</span><br></pre></td></tr></table></figure><p>Now for the time taking part, compiling the sources.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;build.sh -m amd64 -T ..&#x2F;tooldir -D ..&#x2F;destdir -R ..&#x2F;releasedir -O ..&#x2F;objdir -U -j6 release iso-image</span><br><span class="line"># Now get some sleep it&#39;ll take some time.</span><br></pre></td></tr></table></figure><p>Upon completion the directories will have the following files:</p><ul><li>Cross-compilation toolchain in “tooldir”</li><li>Bootable image in “releasedir/images”</li></ul><h2 id="Now-getting-the-guest-up-and-running"><a href="#Now-getting-the-guest-up-and-running" class="headerlink" title="Now getting the guest up and running"></a>Now getting the guest up and running</h2><p>We will be using <code>virt-manager</code> a front-end to qemu for configuring the vm, makes things easier without the hassle of setting up network bridges and all.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install virt-manager</span><br></pre></td></tr></table></figure><p>Once installed open <code>Virtual Machine Manager</code></p><p><img src="/img/setupi/1.png" alt="new vm"><br><img src="/img/setupi/2.png" alt="2"><br><img src="/img/setupi/3.png" alt="3"><br><img src="/img/setupi/4.png" alt="4"><br><img src="/img/setupi/5.png" alt="5"><br><img src="/img/setupi/6.png" alt="6"></p><p>This should drop you a vm instance with the network capabilities too. Now go through the standard netbsd installation procedure installing all the necessary installation sets(depends on what you want to work with) and reboot.</p><h3 id="Configuring-ssh"><a href="#Configuring-ssh" class="headerlink" title="Configuring ssh"></a>Configuring ssh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/ssh/</span><br><span class="line">vi sshd_config</span><br></pre></td></tr></table></figure><p>here you can configure the ssh port and other settings and make sure you have</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure><p>if you want to login as root. After making all the necessary changes,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>This restarts sshd and now you can ssh into your vm.</p><h3 id="Installing-pkgin"><a href="#Installing-pkgin" class="headerlink" title="Installing pkgin"></a>Installing pkgin</h3><p>Once you are up and running better to install pkgin. It makes package management easier but sometimes it messes up in netbsd-current so if you have any problems with installing via pkgin, use pkg_add.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br><span class="line"><span class="built_in">export</span> PKG_URL=<span class="string">"http://cdn.netbsd.org/pub/pkgsrc/packages/NetBSD/amd64/9.0_2019Q4/All"</span></span><br><span class="line"><span class="comment"># change the above url accordingly</span></span><br><span class="line">pkg_add <span class="string">"<span class="variable">$PKG_URL</span>/pkgin-0.9.4nb6.tgz"</span></span><br><span class="line"><span class="comment">#change the above url there will be a newer pkgin version out there.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PKG_URL</span> &gt; /usr/pkg/etc/pkgin/repositories.conf</span><br><span class="line">pkgin update</span><br></pre></td></tr></table></figure><p>Now we can install all (well..most of em) the necessary utilities that makes life easier.</p><h2 id="Compiling-kernels"><a href="#Compiling-kernels" class="headerlink" title="Compiling kernels"></a>Compiling kernels</h2><p>NetBSD runs the default GENERIC configuration. So we make a few changes to this and compile our own kernel.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/netbsd/src/sys/arch/amd64/conf</span><br><span class="line">cp GENERIC QEMU</span><br></pre></td></tr></table></figure><p>Use the text editor of your choice and fiddle with the configuration.</p><p>make sure you have</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makeoptions     DEBUG&#x3D;&quot;-g&quot;      # compile full symbol table for CTF</span><br></pre></td></tr></table></figure><p>Now all that is left is compiling.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./build.sh -m amd64 -T ../tooldir -D ../destdir -R ../releasedir -O ../objdir -U -u -j6 kernel=QEMU</span><br><span class="line"><span class="meta">#</span><span class="bash"> This should complete fairly quick</span></span><br></pre></td></tr></table></figure><p>Now scp the files to vm and repace the old kernel</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scp ~/netbsd/objdir/sys/arch/amd64/compile/QEMU/netbsd root@&lt;ip addr&gt;:~</span><br><span class="line">ssh root@&lt;ip addr&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Virt-manager configures the network so just <span class="keyword">do</span> and ifconfig get the ip address. </span></span><br><span class="line">cp /netbsd /neetbsd.old</span><br><span class="line">cp ~/netbsd /netbsd</span><br><span class="line"><span class="meta">#</span><span class="bash"> Reboot with the new kernel</span></span><br></pre></td></tr></table></figure><h3 id="Debugging-with-gdb"><a href="#Debugging-with-gdb" class="headerlink" title="Debugging with gdb"></a>Debugging with gdb</h3><p>Start VM with qemu’s gdb stub forwarding tcp through port 1234.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -drive file&#x3D;vhd&#x2F;netbsd-current.img,format&#x3D;raw \</span><br><span class="line">                     -m 1024 -enable-kvm \</span><br><span class="line">    -gdb tcp::1234</span><br></pre></td></tr></table></figure><p>We already compiled netbsd kernel with complete symbol table.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;netbsd&#x2F;objdir&#x2F;sys&#x2F;arch&#x2F;amd64&#x2F;compile&#x2F;QEMU</span><br><span class="line">&#x2F;opt&#x2F;bin&#x2F;x86_64-netbsd-gdb .&#x2F;netbsd.gdb</span><br></pre></td></tr></table></figure><p>Now just simply enter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote localhost:1234</span><br><span class="line">Remote debugging using localhost:1234</span><br><span class="line">0xffffffff8021d16e in x86_stihlt ()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is an overview of my setup:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Linux Host With Qemu Target&lt;/li&gt;&lt;li&gt;Tracing and Debugging using qemu’s built-in gdb server.&lt;/
      
    
    </summary>
    
    
    
      <category term="netbsd, environment" scheme="http://adityapadala.com/tags/netbsd-environment/"/>
    
  </entry>
  
  <entry>
    <title>Rump Kernels</title>
    <link href="http://adityapadala.com/2020/04/01/Rump-Kernels/"/>
    <id>http://adityapadala.com/2020/04/01/Rump-Kernels/</id>
    <published>2020-04-01T05:34:45.000Z</published>
    <updated>2020-04-01T07:37:15.344Z</updated>
    
    <content type="html"><![CDATA[<p>The following blogpost is a summary of <a href="http://rumpkernel.org/misc/usenix-login-2014/login_1410_03_kantee.pdf" target="_blank" rel="noopener">Rump Kernels: No OS? No Problem</a>.</p><p>Rumpkernels provide all the necessary components to run applications on baremetal without the necessity of an operating system. Simply put it is way to run kernel code in user space.</p><p>The main goal of rumpkernels in netbsd is to run,debug,examine and develop kernel drivers as easy as possible in the user space without having to run the entire kernel but run the exact same kernel code in userspace. This makes most of the components(drivers) easily portable to different environments.</p><p>Rump Kernels are constructed out of components, So the drivers are built as libraries and these libraries are linked to an interface(some application) that makes use of the libraries(drivers). So we need not build the entire monolithic kernel just the required parts of the kernel.</p><p>For example if we are running a web server all we need is a tcp/ip stack and sockets, We don’t need memory manager, file systems. To achieve this goal we need to find a way to scrape the drivers from the kernel code and must facilitate the rump kernel with i/o device access, memory etc.Here comes the anykernel and hypercall interface.</p><h3 id="Anykernel"><a href="#Anykernel" class="headerlink" title="Anykernel"></a>Anykernel</h3><p>This is the core concept in the implementation of the rumpkernel. Anykernel is using “any” driver/s in any configuration(monolithic/micro/exo). It is analogous to loading kernel modules into any place beyond the operating system.</p><p>The anykernel is divided into 3 abstractions:</p><ul><li>base-Contains fundamental routines(allocators, sync routines)</li><li>factions- filesystem, i/o devices, networking</li><li>drivers-actual driver code to use the factions.</li></ul><p>Consider NFS(Network File System) which is half file system and half network protocol, in order to construct a rump kernel consisting the necessary drivers we must also build they dependent-drivers. But in cases where rumpkernel differs from monolithic kernel we must use some “glue code” to make sure thigns run properly while making sure that the glue code is minimal so as to assure maintainability on NetBSD.</p><h3 id="Hypercalls"><a href="#Hypercalls" class="headerlink" title="Hypercalls"></a>Hypercalls</h3><p>For proper operation of the rump kernel we require require resourcs such as i/o functions and memory. These resources are facilitated by the hypercall interface. It provides a bridge b/w the rumpkernel and the platform the rumpkernel is running on. So we need some bootstrap code to run on the host platform to facilitate this interface. Hypercall is a software trap from the rump kernel to the platform that the rump is running on. Hypercall is to a hypervisor what a syscall is to the kernel.</p><h1 id="Fundamental-Characteristics"><a href="#Fundamental-Characteristics" class="headerlink" title="Fundamental Characteristics"></a>Fundamental Characteristics</h1><p><strong>Rumpkernel is always executed by the host platform.</strong><br>It is similar to just running a binary on the userspace or in Xen(hypervisor used extensively to test rumpkernel not sure why?) ti is just starting a guest domain or on embedded platforms the bootloader loads the rumpkernel into memory and we just <em>jump to the entry point</em> of the rumpkernel code. Quite contrasting to how the monolithic kernel is ran either on hardware or virtualization the only difference arises when executing applications which is not natively possible on rumpkernels(but application layer can be bundled with rumpkernels). We can have different processes communicating with the rumpkernel but either way it is still linked, loaded, executed by the host patform.</p><p><strong>Notion of a CPU core is fictional</strong><br>Usually the CPU configuration is in our hands for a virtual machine or the kernel running on bare metal but this is simply not possible on the rump kernel. The number of cores is actually the number of threads running we can simply all the cpu cores to rump cores for improved performance using caching and locking.</p><p><strong>There is no scheduler</strong><br>Rumpkernels use the platforms thread scheduling policy there is no native scheduler running in rumpkernel<br>so as to avoid the overhead of running scheduler on a scheduler. All the sync ops are defines as hypercall interfaces so that they can be optimized further and avoid classic execution problems(spinlocks/deadlocks). Since there is scheduling policy the host is free to schedule/unschedule the running thread as required.</p><p><strong>No virtual memory concept</strong><br>The rumpkernel simpy runs in the space allocated to it either virtual or not. This is just to remove the cumbersome work of porting the complex memory management operations and the memory manager itself to the rumpkernel when they are explicitly not required. But there are cases where we might need to implement a few custom alternatives to achieve memory manager dependent tasks(mmap()).</p><h3 id="Machine-Independence"><a href="#Machine-Independence" class="headerlink" title="Machine Independence"></a>Machine Independence</h3><p>The rumpkernel code can virtually run on any platform due to their implementation but the only limitation is the driver size so we need enough RAM/ROM to load the rump kernel but can be achieved on a lower scale by trimming down the driver code which obviously ruins the purpose of rumpkernel but still it is possible. What blew my mind is that they were able to achieve the goal of runnibg the rumpkernel on a Javascript Engines.</p><h3 id="Virtual-Uniprocessor-and-Memory-Lock-Avoidance"><a href="#Virtual-Uniprocessor-and-Memory-Lock-Avoidance" class="headerlink" title="Virtual Uniprocessor and Memory Lock Avoidance"></a>Virtual Uniprocessor and Memory Lock Avoidance</h3><p>We can completely avoid the concept of memory locks by using just one processor core in the rumpkernel. So the locking scheme can be implemented in a single file without modifying the driver code.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The following blogpost is a summary of &lt;a href=&quot;http://rumpkernel.org/misc/usenix-login-2014/login_1410_03_kantee.pdf&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
    
      <category term="rump, kernel, rumpkernel, netbsd" scheme="http://adityapadala.com/tags/rump-kernel-rumpkernel-netbsd/"/>
    
  </entry>
  
</feed>
